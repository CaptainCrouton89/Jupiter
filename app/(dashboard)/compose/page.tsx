"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  deleteAttachment,
  getAttachmentUploadUrl,
} from "@/lib/supabase/storage";
import { useEditor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { File as FileIcon, UploadCloud, X as XIcon } from "lucide-react";
import { useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";
import { toast } from "sonner";

// Toolbar component for TipTap editor
// ... existing code ...
// End of EditorToolbar component

// Interface for individual file state
interface AttachmentFile {
  id: string; // Unique ID for the file, e.g., generated by crypto.randomUUID()
  file: File;
  previewUrl?: string; // For image previews
  progress: number; // Upload progress 0-100
  status: "pending" | "uploading" | "success" | "error";
  error?: string; // Error message if upload fails
  storagePath?: string; // Path in Supabase storage after successful upload
}

export default function ComposePage() {
  const router = useRouter();
  const [to, setTo] = useState("");
  const [cc, setCc] = useState("");
  const [bcc, setBcc] = useState("");
  const [subject, setSubject] = useState("");
  const [body, setBody] = useState("");
  const [attachments, setAttachments] = useState<AttachmentFile[]>([]);
  const [isSending, setIsSending] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [draftEmailId, setDraftEmailId] = useState<string>("");

  // Placeholder for session - replace with actual session logic
  const { data: session } = { data: { user: { id: "test-user-id" } } }; // MOCK SESSION

  useEffect(() => {
    // Generate a unique ID for this draft session for associating attachments
    setDraftEmailId(crypto.randomUUID());
  }, []);

  const editor = useEditor({
    extensions: [StarterKit],
    content: body,
    onUpdate: ({ editor: currentEditor }) => {
      setBody(currentEditor.getHTML());
    },
  });

  const handleSend = async () => {
    // TODO: Implement actual email sending logic
    setIsSending(true);
    console.log("Sending email:", { to, cc, bcc, subject, body, attachments });
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 2000));
    setIsSending(false);
    // TODO: Add success toast/notification
    router.push("/inbox"); // Redirect to inbox after sending
  };

  const handleDiscard = () => {
    // TODO: Add confirmation dialog
    router.back(); // Go back to the previous page
  };

  const handleAttachFile = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      setAttachments(
        Array.from(event.target.files).map((file) => ({
          id: crypto.randomUUID(),
          file,
          progress: 0,
          status: "pending",
        }))
      );
    }
  };

  // Placeholder function for sending email
  const handleSendEmail = () => {
    if (!editor) return;
    const emailContent = editor.getHTML();
    console.log("Sending email:", {
      to,
      cc,
      bcc,
      subject,
      emailContent,
      attachments,
    });
    // Actual send logic will be implemented later
    toast.success("Email send action triggered (not implemented yet).");
  };

  // Placeholder function for saving draft
  const handleSaveDraft = () => {
    if (!editor) return;
    const emailContent = editor.getHTML();
    console.log("Saving draft:", {
      to,
      cc,
      bcc,
      subject,
      emailContent,
      attachments,
    });
    // Actual draft saving logic will be implemented later
    toast("Draft save action triggered (not implemented yet).");
  };

  // Handle file selection from input or drag-and-drop
  const handleFileSelect = async (selectedFiles: FileList | null) => {
    if (!selectedFiles) return;

    const newAttachmentFiles: AttachmentFile[] = [];
    for (let i = 0; i < selectedFiles.length; i++) {
      const file = selectedFiles[i];
      // TODO: Add client-side validation for file type and size here
      const MAX_FILE_SIZE_MB = 10;
      const ALLOWED_FILE_TYPES = [
        "image/jpeg",
        "image/png",
        "application/pdf",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document", // .docx
      ];

      if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
        toast.error(
          `File "${file.name}" is too large. Max size is ${MAX_FILE_SIZE_MB}MB.`
        );
        continue; // Skip this file
      }

      if (!ALLOWED_FILE_TYPES.includes(file.type)) {
        toast.error(
          `File type for "${file.name}" is not allowed. Allowed: JPG, PNG, PDF, DOCX.`
        );
        continue; // Skip this file
      }

      let previewUrl: string | undefined = undefined;
      if (file.type.startsWith("image/")) {
        previewUrl = URL.createObjectURL(file);
      }

      newAttachmentFiles.push({
        id: crypto.randomUUID(),
        file,
        previewUrl,
        progress: 0,
        status: "pending",
      });
    }
    setAttachments((prev) => [...prev, ...newAttachmentFiles]);
    // TODO: Trigger actual upload process for each file
    newAttachmentFiles.forEach(uploadFile);
  };

  // Actual file upload logic
  const uploadFile = async (attachment: AttachmentFile) => {
    if (!session?.user?.id || !draftEmailId) {
      toast.error("User session or draft ID is missing. Cannot upload.");
      setAttachments((prev) =>
        prev.map((att) =>
          att.id === attachment.id
            ? { ...att, status: "error", error: "Session missing" }
            : att
        )
      );
      return;
    }

    setAttachments((prev) =>
      prev.map((att) =>
        att.id === attachment.id
          ? { ...att, status: "uploading", progress: 0 }
          : att
      )
    );

    try {
      const {
        uploadUrl,
        filePath,
        error: urlError,
      } = await getAttachmentUploadUrl(
        session.user.id,
        draftEmailId,
        attachment.file.name
      );

      if (urlError || !uploadUrl || !filePath) {
        console.error("Error getting upload URL:", urlError);
        throw new Error(urlError?.message || "Failed to get upload URL.");
      }

      const xhr = new XMLHttpRequest();
      xhr.open("PUT", uploadUrl, true);
      // If your Supabase storage RLS for uploads doesn't rely on Content-Type from the signed URL generation,
      // you might need to set it. Often, it's part of the signed URL's policy.
      // xhr.setRequestHeader('Content-Type', attachment.file.type);

      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable) {
          const progress = Math.round((event.loaded / event.total) * 100);
          setAttachments((prev) =>
            prev.map((att) =>
              att.id === attachment.id ? { ...att, progress } : att
            )
          );
        }
      };

      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          setAttachments((prev) =>
            prev.map((att) =>
              att.id === attachment.id
                ? {
                    ...att,
                    status: "success",
                    progress: 100,
                    storagePath: filePath,
                  }
                : att
            )
          );
          toast.success(`Uploaded "${attachment.file.name}" successfully!`);
        } else {
          const errorResponse =
            xhr.responseText || `Upload failed with status ${xhr.status}`;
          console.error(
            "Upload error:",
            errorResponse,
            xhr.status,
            xhr.statusText
          );
          throw new Error(errorResponse);
        }
      };

      xhr.onerror = () => {
        console.error("XHR onerror triggered");
        throw new Error("Network error during upload.");
      };

      xhr.send(attachment.file);
    } catch (error: any) {
      console.error(`Failed to upload ${attachment.file.name}:`, error);
      setAttachments((prev) =>
        prev.map((att) =>
          att.id === attachment.id
            ? {
                ...att,
                status: "error",
                error: error.message || "Upload failed",
              }
            : att
        )
      );
      toast.error(`Failed to upload "${attachment.file.name}".`);
    }
  };

  // Handle removing an attachment
  const handleRemoveAttachment = async (fileIdToRemove: string) => {
    const attachmentToRemove = attachments.find(
      (att) => att.id === fileIdToRemove
    );
    if (!attachmentToRemove) return;

    // Optimistically remove from UI first
    setAttachments((prev) =>
      prev.filter((att) => {
        if (att.id === fileIdToRemove && att.previewUrl) {
          URL.revokeObjectURL(att.previewUrl); // Clean up object URL
        }
        return att.id !== fileIdToRemove;
      })
    );

    // If the file was successfully uploaded, attempt to delete it from storage
    if (
      attachmentToRemove.status === "success" &&
      attachmentToRemove.storagePath
    ) {
      try {
        const { success, error } = await deleteAttachment(
          attachmentToRemove.storagePath
        );
        if (success) {
          toast.success(
            `"${attachmentToRemove.file.name}" removed successfully.`
          );
        } else {
          console.error("Error deleting attachment from storage:", error);
          toast.error(
            `Failed to remove "${attachmentToRemove.file.name}" from storage: ${
              error?.message || "Unknown error"
            }`
          );
          // Optionally, add it back to the UI if deletion failed, though this might be complex
          // For now, it remains removed from UI even if server deletion fails.
        }
      } catch (err: any) {
        console.error(
          "Catch block: Error deleting attachment from storage:",
          err
        );
        toast.error(
          `Error removing "${attachmentToRemove.file.name}" from storage: ${
            err.message || "Unknown error"
          }`
        );
      }
    } else if (attachmentToRemove.status === "uploading") {
      // TODO: Implement aborting XHR request if an upload is in progress.
      // This requires storing the XHR object with the AttachmentFile state.
      // For now, we just log it.
      console.warn(
        `Attachment "${attachmentToRemove.file.name}" was being uploaded. Abort logic not yet implemented.`
      );
      toast.info(
        `Upload of "${attachmentToRemove.file.name}" was in progress. File removed from list.`
      );
    } else if (
      attachmentToRemove.status === "error" ||
      attachmentToRemove.status === "pending"
    ) {
      // If it was pending or errored, it wasn't uploaded, so just remove from UI (already done)
      toast.info(`"${attachmentToRemove.file.name}" removed from list.`);
    }
  };

  return (
    <div className="container mx-auto max-w-4xl p-4 md:p-6">
      <div className="flex items-center justify-between mb-6 pb-4 border-b">
        <h1 className="text-2xl font-semibold">Compose Email</h1>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            onClick={handleDiscard}
            disabled={isSending}
          >
            Discard
          </Button>
          <Button onClick={handleSend} disabled={isSending}>
            {isSending ? "Sending..." : "Send"}
          </Button>
        </div>
      </div>

      <form
        onSubmit={(e: React.FormEvent<HTMLFormElement>) => {
          e.preventDefault();
          handleSend();
        }}
        className="space-y-6"
      >
        <div>
          <Label htmlFor="to">To</Label>
          <Input
            id="to"
            type="email"
            value={to}
            onChange={(e) => setTo(e.target.value)}
            placeholder="recipient@example.com"
            required
            disabled={isSending}
          />
        </div>
        <div>
          <Label htmlFor="cc">Cc</Label>
          <Input
            id="cc"
            type="email"
            value={cc}
            onChange={(e) => setCc(e.target.value)}
            placeholder="carbon.copy@example.com"
            disabled={isSending}
          />
        </div>
        <div>
          <Label htmlFor="bcc">Bcc</Label>
          <Input
            id="bcc"
            type="email"
            value={bcc}
            onChange={(e) => setBcc(e.target.value)}
            placeholder="blind.carbon.copy@example.com"
            disabled={isSending}
          />
        </div>
        <div>
          <Label htmlFor="subject">Subject</Label>
          <Input
            id="subject"
            type="text"
            value={subject}
            onChange={(e) => setSubject(e.target.value)}
            placeholder="Email subject"
            required
            disabled={isSending}
          />
        </div>
        <div>
          <Label htmlFor="body">Body</Label>
          {/* TODO: Replace with Rich Text Editor */}
          <Textarea
            id="body"
            value={body}
            onChange={(e) => setBody(e.target.value)}
            placeholder="Write your email here..."
            rows={15}
            required
            disabled={isSending}
            className="min-h-[300px]"
          />
        </div>

        <div>
          <Label htmlFor="attachments">Attachments</Label>
          <div
            className="relative flex flex-col items-center justify-center w-full p-6 border-2 border-dashed rounded-lg cursor-pointer border-muted hover:border-primary transition-colors"
            onDragOver={(e) => {
              e.preventDefault();
              e.currentTarget.classList.add("border-primary");
            }}
            onDragLeave={(e) => {
              e.currentTarget.classList.remove("border-primary");
            }}
            onDrop={(e) => {
              e.preventDefault();
              e.currentTarget.classList.remove("border-primary");
              handleFileSelect(e.dataTransfer.files);
            }}
            onClick={() => fileInputRef.current?.click()}
          >
            <UploadCloud className="w-10 h-10 text-muted-foreground mb-2" />
            <p className="mb-1 text-sm text-muted-foreground">
              <span className="font-semibold">Click to upload</span> or drag and
              drop
            </p>
            <p className="text-xs text-muted-foreground">
              Max file size: 10MB. Allowed types: JPG, PNG, PDF, DOCX
            </p>
            <input
              type="file"
              ref={fileInputRef}
              multiple
              className="hidden"
              onChange={(e) => handleFileSelect(e.target.files)}
              // TODO: Add accept attribute for allowed file types
              accept=".jpg,.jpeg,.png,.pdf,.docx"
            />
          </div>

          {attachments.length > 0 && (
            <div className="mt-2 space-y-2">
              {attachments.map((att) => (
                <div
                  key={att.id}
                  className="flex items-center justify-between p-2 border rounded-md bg-muted/30"
                >
                  <div className="flex items-center space-x-2 overflow-hidden">
                    {att.previewUrl ? (
                      <img
                        src={att.previewUrl}
                        alt={att.file.name}
                        className="w-10 h-10 object-cover rounded"
                      />
                    ) : (
                      <FileIcon className="w-8 h-8 text-muted-foreground" />
                    )}
                    <div className="flex flex-col overflow-hidden">
                      <span
                        className="text-sm font-medium truncate"
                        title={att.file.name}
                      >
                        {att.file.name}
                      </span>
                      <span className="text-xs text-muted-foreground">
                        {Math.round(att.file.size / 1024)} KB
                      </span>
                    </div>
                  </div>
                  {att.status === "uploading" && (
                    <div className="w-16 h-1.5 bg-muted rounded-full overflow-hidden mx-2">
                      <div
                        className="h-full bg-primary transition-all duration-150"
                        style={{ width: `${att.progress}%` }}
                      />
                    </div>
                  )}
                  {att.status === "error" && (
                    <span
                      className="text-xs text-destructive mx-2"
                      title={att.error}
                    >
                      Error
                    </span>
                  )}
                  <Button
                    variant="ghost"
                    size="icon"
                    className="text-muted-foreground hover:text-destructive"
                    onClick={() => handleRemoveAttachment(att.id)}
                  >
                    <XIcon className="w-4 h-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button
            variant="outline"
            type="button"
            onClick={handleDiscard}
            disabled={isSending}
          >
            Discard
          </Button>
          <Button type="submit" disabled={isSending}>
            {isSending ? "Sending..." : "Send"}
          </Button>
        </div>
      </form>
    </div>
  );
}
